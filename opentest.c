/*

	Test EMFILE error recovery.    

	Copyright (c) 1994 by the Trustees of Dartmouth College; 
	see the file 'Copyright' in the distribution for conditions of use.

*/
#include "port.h"
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <syslog.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include "t_io.h"
#include "mbox.h"
#include "t_err.h"
#include "misc.h"
#include "config.h"
#include "mess.h"

int	finished = 0;
pthread_cond_t finish_wait;
#define THREADCOUNT 50
#define LOOPCOUNT 5000

any_t openthread(any_t _threadnum);

void doshutdown() {}

int main (int argc, char **argv) {

    int		i;
    pthread_t	thread;
    	
    misc_init(); 			/* initialize global locks */
    pthread_cond_init(&finish_wait, pthread_condattr_default);
    
    t_ioinit();
    t_errinit("fopentest", LOG_LOCAL1);	/* initialize error package */
    
    t_errprint("Up");
        
    for (i = 0; i < THREADCOUNT; ++i) {
	if (pthread_create(&thread, generic_attr, 
			(pthread_startroutine_t) openthread, (pthread_addr_t) i) < 0) {
	   t_perror("pthread_create");
	} else
	    pthread_detach(&thread);
    }
    pthread_mutex_lock(&syslog_lock);
    fprintf(stderr, "Threads spawned\n");
    pthread_mutex_unlock(&syslog_lock); 
    
    /* wait for all threads to finish */
    pthread_mutex_lock(&global_lock);
    while(finished < THREADCOUNT)
	pthread_cond_wait(&finish_wait, &global_lock);

    fprintf(stderr, "** %s:  Done.\n**\n", argv[0]);
    
    exit(0);
}

any_t openthread(pthread_addr_t _threadnum) {

    int		threadnum;	
    int		i;
    t_file	*f;
    
    threadnum = (long) _threadnum;		

    pthread_mutex_lock(&syslog_lock);
    fprintf(stderr, "Thread %d; start\n", threadnum);
    pthread_mutex_unlock(&syslog_lock); 
        
    for (i = 0; i < LOOPCOUNT; ++i) {
	if ((f = t_fopen("/etc/hosts", O_RDONLY, 0)) == NULL) {
	    t_perror("open");
	}	
	t_fclose(f);
    }

    pthread_mutex_lock(&global_lock);	/* count threads that have finished */
    ++finished;
    pthread_mutex_unlock(&global_lock);
    pthread_cond_signal(&finish_wait);	/* wake main thread */

    pthread_mutex_lock(&syslog_lock);
    fprintf(stderr, "Thread %d; done\n", threadnum);
    pthread_mutex_unlock(&syslog_lock); 
    
    return 0;				/* thread fades away */
}

